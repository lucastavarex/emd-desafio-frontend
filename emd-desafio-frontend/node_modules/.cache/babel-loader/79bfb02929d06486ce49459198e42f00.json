{"ast":null,"code":"(function (global, factory) {\n  typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() : typeof define === 'function' && define.amd ? define(factory) : global.scrollama = factory();\n})(this, function () {\n  'use strict';\n\n  // DOM helper functions\n\n  // private\n  function selectionToArray(selection) {\n    var len = selection.length;\n    var result = [];\n    for (var i = 0; i < len; i += 1) {\n      result.push(selection[i]);\n    }\n    return result;\n  }\n  function selectAll(selector, parent) {\n    if (parent === void 0) parent = document;\n    if (typeof selector === 'string') {\n      return selectionToArray(parent.querySelectorAll(selector));\n    } else if (selector instanceof Element) {\n      return selectionToArray([selector]);\n    } else if (selector instanceof NodeList) {\n      return selectionToArray(selector);\n    } else if (selector instanceof Array) {\n      return selector;\n    }\n    return [];\n  }\n  function getStepId(ref) {\n    var id = ref.id;\n    var i = ref.i;\n    return \"scrollama__debug-step--\" + id + \"-\" + i;\n  }\n  function getOffsetId(ref) {\n    var id = ref.id;\n    return \"scrollama__debug-offset--\" + id;\n  }\n\n  // SETUP\n\n  function setupOffset(ref) {\n    var id = ref.id;\n    var offsetVal = ref.offsetVal;\n    var stepClass = ref.stepClass;\n    var el = document.createElement('div');\n    el.setAttribute('id', getOffsetId({\n      id: id\n    }));\n    el.setAttribute('class', 'scrollama__debug-offset');\n    el.style.position = 'fixed';\n    el.style.left = '0';\n    el.style.width = '100%';\n    el.style.height = '0px';\n    el.style.borderTop = '2px dashed black';\n    el.style.zIndex = '9999';\n    var text = document.createElement('p');\n    text.innerText = \"\\\".\" + stepClass + \"\\\" trigger: \" + offsetVal;\n    text.style.fontSize = '12px';\n    text.style.fontFamily = 'monospace';\n    text.style.color = 'black';\n    text.style.margin = '0';\n    text.style.padding = '6px';\n    el.appendChild(text);\n    document.body.appendChild(el);\n  }\n  function setup(ref) {\n    var id = ref.id;\n    var offsetVal = ref.offsetVal;\n    var stepEl = ref.stepEl;\n    var stepClass = stepEl[0].getAttribute('class');\n    setupOffset({\n      id: id,\n      offsetVal: offsetVal,\n      stepClass: stepClass\n    });\n  }\n\n  // UPDATE\n  function updateOffset(ref) {\n    var id = ref.id;\n    var offsetMargin = ref.offsetMargin;\n    var offsetVal = ref.offsetVal;\n    var idVal = getOffsetId({\n      id: id\n    });\n    var el = document.querySelector(\"#\" + idVal);\n    el.style.top = offsetMargin + \"px\";\n  }\n  function update(ref) {\n    var id = ref.id;\n    var stepOffsetHeight = ref.stepOffsetHeight;\n    var offsetMargin = ref.offsetMargin;\n    var offsetVal = ref.offsetVal;\n    updateOffset({\n      id: id,\n      offsetMargin: offsetMargin\n    });\n  }\n  function notifyStep(ref) {\n    var id = ref.id;\n    var index = ref.index;\n    var state = ref.state;\n    var idVal = getStepId({\n      id: id,\n      i: index\n    });\n    var elA = document.querySelector(\"#\" + idVal + \"_above\");\n    var elB = document.querySelector(\"#\" + idVal + \"_below\");\n    var display = state === 'enter' ? 'block' : 'none';\n    if (elA) {\n      elA.style.display = display;\n    }\n    if (elB) {\n      elB.style.display = display;\n    }\n  }\n  function scrollama() {\n    var OBSERVER_NAMES = ['stepAbove', 'stepBelow', 'stepProgress', 'viewportAbove', 'viewportBelow'];\n    var cb = {\n      stepEnter: function () {},\n      stepExit: function () {},\n      stepProgress: function () {}\n    };\n    var io = {};\n    var id = null;\n    var stepEl = [];\n    var stepOffsetHeight = [];\n    var stepOffsetTop = [];\n    var stepStates = [];\n    var offsetVal = 0;\n    var offsetMargin = 0;\n    var viewH = 0;\n    var pageH = 0;\n    var previousYOffset = 0;\n    var progressThreshold = 0;\n    var isReady = false;\n    var isEnabled = false;\n    var isDebug = false;\n    var progressMode = false;\n    var preserveOrder = false;\n    var triggerOnce = false;\n    var direction = 'down';\n    var exclude = [];\n\n    /*** HELPERS ***/\n    function generateInstanceID() {\n      var a = 'abcdefghijklmnopqrstuv';\n      var l = a.length;\n      var t = Date.now();\n      var r = [0, 0, 0].map(function (d) {\n        return a[Math.floor(Math.random() * l)];\n      }).join('');\n      return \"\" + r + t;\n    }\n\n    //www.gomakethings.com/how-to-get-an-elements-distance-from-the-top-of-the-page-with-vanilla-javascript/\n    function getOffsetTop(el) {\n      // Set our distance placeholder\n      var distance = 0;\n\n      // Loop up the DOM\n      if (el.offsetParent) {\n        do {\n          distance += el.offsetTop;\n          el = el.offsetParent;\n        } while (el);\n      }\n\n      // Return our distance\n      return distance < 0 ? 0 : distance;\n    }\n    function getPageHeight() {\n      var body = document.body;\n      var html = document.documentElement;\n      return Math.max(body.scrollHeight, body.offsetHeight, html.clientHeight, html.scrollHeight, html.offsetHeight);\n    }\n    function getIndex(element) {\n      return +element.getAttribute('data-scrollama-index');\n    }\n    function updateDirection() {\n      if (window.pageYOffset > previousYOffset) {\n        direction = 'down';\n      } else if (window.pageYOffset < previousYOffset) {\n        direction = 'up';\n      }\n      previousYOffset = window.pageYOffset;\n    }\n    function disconnectObserver(name) {\n      if (io[name]) {\n        io[name].forEach(function (d) {\n          return d.disconnect();\n        });\n      }\n    }\n    function handleResize() {\n      viewH = window.innerHeight;\n      pageH = getPageHeight();\n      offsetMargin = offsetVal * viewH;\n      if (isReady) {\n        stepOffsetHeight = stepEl.map(function (el) {\n          return el.offsetHeight;\n        });\n        stepOffsetTop = stepEl.map(getOffsetTop);\n        if (isEnabled) {\n          updateIO();\n        }\n      }\n      if (isDebug) {\n        update({\n          id: id,\n          stepOffsetHeight: stepOffsetHeight,\n          offsetMargin: offsetMargin,\n          offsetVal: offsetVal\n        });\n      }\n    }\n    function handleEnable(enable) {\n      if (enable && !isEnabled) {\n        if (isReady) {\n          updateIO();\n        }\n        isEnabled = true;\n        return true;\n      }\n      OBSERVER_NAMES.forEach(disconnectObserver);\n      isEnabled = false;\n    }\n    function createThreshold(height) {\n      var count = Math.ceil(height / progressThreshold);\n      var t = [];\n      var ratio = 1 / count;\n      for (var i = 0; i < count; i++) {\n        t.push(i * ratio);\n      }\n      return t;\n    }\n\n    /*** NOTIFY CALLBACKS ***/\n\n    function notifyStepProgress(element, progress) {\n      var index = getIndex(element);\n      if (progress !== undefined) {\n        stepStates[index].progress = progress;\n      }\n      var resp = {\n        element: element,\n        index: index,\n        progress: stepStates[index].progress\n      };\n      if (stepStates[index].state === 'enter') {\n        cb.stepProgress(resp);\n      }\n    }\n    function notifyOthers(index, location) {\n      if (location === 'above') {\n        // check if steps above/below were skipped and should be notified first\n        for (var i = 0; i < index; i++) {\n          var ss = stepStates[i];\n          if (ss.state !== 'enter' && ss.direction !== 'down') {\n            notifyStepEnter(stepEl[i], 'down', false);\n            notifyStepExit(stepEl[i], 'down');\n          } else if (ss.state === 'enter') {\n            notifyStepExit(stepEl[i], 'down');\n          }\n          // else if (ss.direction === 'up') {\n          //   notifyStepEnter(stepEl[i], 'down', false);\n          //   notifyStepExit(stepEl[i], 'down');\n          // }\n        }\n      } else if (location === 'below') {\n        for (var i$1 = stepStates.length - 1; i$1 > index; i$1--) {\n          var ss$1 = stepStates[i$1];\n          if (ss$1.state === 'enter') {\n            notifyStepExit(stepEl[i$1], 'up');\n          }\n          if (ss$1.direction === 'down') {\n            notifyStepEnter(stepEl[i$1], 'up', false);\n            notifyStepExit(stepEl[i$1], 'up');\n          }\n        }\n      }\n    }\n    function notifyStepEnter(element, direction, check) {\n      if (check === void 0) check = true;\n      var index = getIndex(element);\n      var resp = {\n        element: element,\n        index: index,\n        direction: direction\n      };\n\n      // store most recent trigger\n      stepStates[index].direction = direction;\n      stepStates[index].state = 'enter';\n      if (preserveOrder && check && direction === 'down') {\n        notifyOthers(index, 'above');\n      }\n      if (preserveOrder && check && direction === 'up') {\n        notifyOthers(index, 'below');\n      }\n      if (cb.stepEnter && !exclude[index]) {\n        cb.stepEnter(resp, stepStates);\n        if (isDebug) {\n          notifyStep({\n            id: id,\n            index: index,\n            state: 'enter'\n          });\n        }\n        if (triggerOnce) {\n          exclude[index] = true;\n        }\n      }\n      if (progressMode) {\n        notifyStepProgress(element);\n      }\n    }\n    function notifyStepExit(element, direction) {\n      var index = getIndex(element);\n      var resp = {\n        element: element,\n        index: index,\n        direction: direction\n      };\n      if (progressMode) {\n        if (direction === 'down' && stepStates[index].progress < 1) {\n          notifyStepProgress(element, 1);\n        } else if (direction === 'up' && stepStates[index].progress > 0) {\n          notifyStepProgress(element, 0);\n        }\n      }\n\n      // store most recent trigger\n      stepStates[index].direction = direction;\n      stepStates[index].state = 'exit';\n      cb.stepExit(resp, stepStates);\n      if (isDebug) {\n        notifyStep({\n          id: id,\n          index: index,\n          state: 'exit'\n        });\n      }\n    }\n\n    /*** OBSERVER - INTERSECT HANDLING ***/\n    // this is good for entering while scrolling down + leaving while scrolling up\n    function intersectStepAbove(ref) {\n      var entry = ref[0];\n      updateDirection();\n      var isIntersecting = entry.isIntersecting;\n      var boundingClientRect = entry.boundingClientRect;\n      var target = entry.target;\n\n      // bottom = bottom edge of element from top of viewport\n      // bottomAdjusted = bottom edge of element from trigger\n      var top = boundingClientRect.top;\n      var bottom = boundingClientRect.bottom;\n      var topAdjusted = top - offsetMargin;\n      var bottomAdjusted = bottom - offsetMargin;\n      var index = getIndex(target);\n      var ss = stepStates[index];\n\n      // entering above is only when topAdjusted is negative\n      // and bottomAdjusted is positive\n      if (isIntersecting && topAdjusted <= 0 && bottomAdjusted >= 0 && direction === 'down' && ss.state !== 'enter') {\n        notifyStepEnter(target, direction);\n      }\n\n      // exiting from above is when topAdjusted is positive and not intersecting\n      if (!isIntersecting && topAdjusted > 0 && direction === 'up' && ss.state === 'enter') {\n        notifyStepExit(target, direction);\n      }\n    }\n\n    // this is good for entering while scrolling up + leaving while scrolling down\n    function intersectStepBelow(ref) {\n      var entry = ref[0];\n      updateDirection();\n      var isIntersecting = entry.isIntersecting;\n      var boundingClientRect = entry.boundingClientRect;\n      var target = entry.target;\n\n      // bottom = bottom edge of element from top of viewport\n      // bottomAdjusted = bottom edge of element from trigger\n      var top = boundingClientRect.top;\n      var bottom = boundingClientRect.bottom;\n      var topAdjusted = top - offsetMargin;\n      var bottomAdjusted = bottom - offsetMargin;\n      var index = getIndex(target);\n      var ss = stepStates[index];\n\n      // entering below is only when bottomAdjusted is positive\n      // and topAdjusted is positive\n      if (isIntersecting && topAdjusted <= 0 && bottomAdjusted >= 0 && direction === 'up' && ss.state !== 'enter') {\n        notifyStepEnter(target, direction);\n      }\n\n      // exiting from above is when bottomAdjusted is negative and not intersecting\n      if (!isIntersecting && bottomAdjusted < 0 && direction === 'down' && ss.state === 'enter') {\n        notifyStepExit(target, direction);\n      }\n    }\n\n    /*\n    if there is a scroll event where a step never intersects (therefore\n    skipping an enter/exit trigger), use this fallback to detect if it is\n    in view\n    */\n    function intersectViewportAbove(ref) {\n      var entry = ref[0];\n      updateDirection();\n      var isIntersecting = entry.isIntersecting;\n      var target = entry.target;\n      var index = getIndex(target);\n      var ss = stepStates[index];\n      if (isIntersecting && direction === 'down' && ss.direction !== 'down' && ss.state !== 'enter') {\n        notifyStepEnter(target, 'down');\n        notifyStepExit(target, 'down');\n      }\n    }\n    function intersectViewportBelow(ref) {\n      var entry = ref[0];\n      updateDirection();\n      var isIntersecting = entry.isIntersecting;\n      var target = entry.target;\n      var index = getIndex(target);\n      var ss = stepStates[index];\n      if (isIntersecting && direction === 'up' && ss.direction === 'down' && ss.state !== 'enter') {\n        notifyStepEnter(target, 'up');\n        notifyStepExit(target, 'up');\n      }\n    }\n    function intersectStepProgress(ref) {\n      var entry = ref[0];\n      updateDirection();\n      var isIntersecting = entry.isIntersecting;\n      var intersectionRatio = entry.intersectionRatio;\n      var boundingClientRect = entry.boundingClientRect;\n      var target = entry.target;\n      var bottom = boundingClientRect.bottom;\n      var bottomAdjusted = bottom - offsetMargin;\n      if (isIntersecting && bottomAdjusted >= 0) {\n        notifyStepProgress(target, +intersectionRatio.toFixed(3));\n      }\n    }\n\n    /***  OBSERVER - CREATION ***/\n    // jump into viewport\n    function updateViewportAboveIO() {\n      io.viewportAbove = stepEl.map(function (el, i) {\n        var marginTop = pageH - stepOffsetTop[i];\n        var marginBottom = offsetMargin - viewH - stepOffsetHeight[i];\n        var rootMargin = marginTop + \"px 0px \" + marginBottom + \"px 0px\";\n        var options = {\n          rootMargin: rootMargin\n        };\n        // console.log(options);\n        var obs = new IntersectionObserver(intersectViewportAbove, options);\n        obs.observe(el);\n        return obs;\n      });\n    }\n    function updateViewportBelowIO() {\n      io.viewportBelow = stepEl.map(function (el, i) {\n        var marginTop = -offsetMargin - stepOffsetHeight[i];\n        var marginBottom = offsetMargin - viewH + stepOffsetHeight[i] + pageH;\n        var rootMargin = marginTop + \"px 0px \" + marginBottom + \"px 0px\";\n        var options = {\n          rootMargin: rootMargin\n        };\n        // console.log(options);\n        var obs = new IntersectionObserver(intersectViewportBelow, options);\n        obs.observe(el);\n        return obs;\n      });\n    }\n\n    // look above for intersection\n    function updateStepAboveIO() {\n      io.stepAbove = stepEl.map(function (el, i) {\n        var marginTop = -offsetMargin + stepOffsetHeight[i];\n        var marginBottom = offsetMargin - viewH;\n        var rootMargin = marginTop + \"px 0px \" + marginBottom + \"px 0px\";\n        var options = {\n          rootMargin: rootMargin\n        };\n        // console.log(options);\n        var obs = new IntersectionObserver(intersectStepAbove, options);\n        obs.observe(el);\n        return obs;\n      });\n    }\n\n    // look below for intersection\n    function updateStepBelowIO() {\n      io.stepAbove = stepEl.map(function (el, i) {\n        var marginTop = -offsetMargin;\n        var marginBottom = offsetMargin - viewH + stepOffsetHeight[i];\n        var rootMargin = marginTop + \"px 0px \" + marginBottom + \"px 0px\";\n        var options = {\n          rootMargin: rootMargin\n        };\n        // console.log(options);\n        var obs = new IntersectionObserver(intersectStepBelow, options);\n        obs.observe(el);\n        return obs;\n      });\n    }\n\n    // progress progress tracker\n    function updateStepProgressIO() {\n      io.stepProgress = stepEl.map(function (el, i) {\n        var marginTop = stepOffsetHeight[i] - offsetMargin;\n        var marginBottom = -viewH + offsetMargin;\n        var rootMargin = marginTop + \"px 0px \" + marginBottom + \"px 0px\";\n        var threshold = createThreshold(stepOffsetHeight[i]);\n        var options = {\n          rootMargin: rootMargin,\n          threshold: threshold\n        };\n        // console.log(options);\n        var obs = new IntersectionObserver(intersectStepProgress, options);\n        obs.observe(el);\n        return obs;\n      });\n    }\n    function updateIO() {\n      OBSERVER_NAMES.forEach(disconnectObserver);\n      updateViewportAboveIO();\n      updateViewportBelowIO();\n      updateStepAboveIO();\n      updateStepBelowIO();\n      if (progressMode) {\n        updateStepProgressIO();\n      }\n    }\n\n    /*** SETUP FUNCTIONS ***/\n\n    function indexSteps() {\n      stepEl.forEach(function (el, i) {\n        return el.setAttribute('data-scrollama-index', i);\n      });\n    }\n    function setupStates() {\n      stepStates = stepEl.map(function () {\n        return {\n          direction: null,\n          state: null,\n          progress: 0\n        };\n      });\n    }\n    function addDebug() {\n      if (isDebug) {\n        setup({\n          id: id,\n          stepEl: stepEl,\n          offsetVal: offsetVal\n        });\n      }\n    }\n    var S = {};\n    S.setup = function (ref) {\n      var step = ref.step;\n      var offset = ref.offset;\n      if (offset === void 0) offset = 0.5;\n      var progress = ref.progress;\n      if (progress === void 0) progress = false;\n      var threshold = ref.threshold;\n      if (threshold === void 0) threshold = 4;\n      var debug = ref.debug;\n      if (debug === void 0) debug = false;\n      var order = ref.order;\n      if (order === void 0) order = true;\n      var once = ref.once;\n      if (once === void 0) once = false;\n\n      // create id unique to this scrollama instance\n      id = generateInstanceID();\n      stepEl = selectAll(step);\n      if (!stepEl.length) {\n        console.error('scrollama error: no step elements');\n        return S;\n      }\n\n      // options\n      isDebug = debug;\n      progressMode = progress;\n      preserveOrder = order;\n      triggerOnce = once;\n      S.offsetTrigger(offset);\n      progressThreshold = Math.max(1, +threshold);\n      isReady = true;\n\n      // customize\n      addDebug();\n      indexSteps();\n      setupStates();\n      handleResize();\n      S.enable();\n      return S;\n    };\n    S.resize = function () {\n      handleResize();\n      return S;\n    };\n    S.enable = function () {\n      handleEnable(true);\n      return S;\n    };\n    S.disable = function () {\n      handleEnable(false);\n      return S;\n    };\n    S.destroy = function () {\n      handleEnable(false);\n      Object.keys(cb).forEach(function (c) {\n        return cb[c] = null;\n      });\n      Object.keys(io).forEach(function (i) {\n        return io[i] = null;\n      });\n    };\n    S.offsetTrigger = function (x) {\n      if (x && !isNaN(x)) {\n        if (x > 1) {\n          console.error('scrollama error: offset value is greater than 1. Fallbacks to 1.');\n        }\n        if (x < 0) {\n          console.error('scrollama error: offset value is lower than 0. Fallbacks to 0.');\n        }\n        offsetVal = Math.min(Math.max(0, x), 1);\n        return S;\n      } else if (isNaN(x)) {\n        console.error('scrollama error: offset value is not a number. Fallbacks to 0.');\n      }\n      return offsetVal;\n    };\n    S.onStepEnter = function (f) {\n      if (typeof f === 'function') {\n        cb.stepEnter = f;\n      } else {\n        console.error('scrollama error: onStepEnter requires a function');\n      }\n      return S;\n    };\n    S.onStepExit = function (f) {\n      if (typeof f === 'function') {\n        cb.stepExit = f;\n      } else {\n        console.error('scrollama error: onStepExit requires a function');\n      }\n      return S;\n    };\n    S.onStepProgress = function (f) {\n      if (typeof f === 'function') {\n        cb.stepProgress = f;\n      } else {\n        console.error('scrollama error: onStepProgress requires a function');\n      }\n      return S;\n    };\n    return S;\n  }\n  return scrollama;\n});","map":null,"metadata":{},"sourceType":"script"}